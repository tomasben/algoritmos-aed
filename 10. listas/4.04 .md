## 4.04
Se dispone de una lista simplemente encadenada cuyos registros están ordenados
en forma ascendente por una clave de tipo entero; diseñar un algoritmo que
invierta el orden de la lista.

2 formas de invertir una lista
- Mas facil y menos eficiente, creando una nueva: en cada paso se añade los
nodos al *final* de la segunda lista y su prox apunta al anterior (las flechas cambian de sentido).
- Mas difícil y eficiente, dentro de la misma: se necesitan 3 punteros, uno
para el nodo `previo`, `actual` y `siguiente`. En cada paso se realiza:
`actual.prox := previo`, luego previo pasa a ser el actual y el actual,
pasa a ser el siguiente.

```
ACCION algoritmo(prim: puntero a Nodo) ES
  AMBIENTE
    Nodo = REGISTRO
      dato: entero
      prox: puntero a Nodo
    FIN_REGISTRO

    prim, p: puntero a Nodo
    prim2, q: puntero a Nodo
  PROCESO
    p := prim
    prim2 := nil

    MIENTRAS (p <> nil) HACER
      NUEVO(q)
      *q.dato := *p.dato

      *q.prox := prim2
      prim2 := q

      p := *p.prox
    FIN_MIENTRAS
FIN_ACCION
```
